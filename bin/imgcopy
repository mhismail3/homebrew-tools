#!/usr/bin/env python3
"""
imgcopy - Multi-provider image text extraction and cleanup

Extract text from images using OpenAI, Anthropic, Gemini, or Mistral vision APIs.

Usage:
    imgcopy <image-path>
    imgcopy <image-path> --clean           # Format, sanitize, and copy
    imgcopy <image-path> -p openai         # Use specific provider
    imgcopy <image-path> -m gpt-4o         # Use specific model
    imgcopy <image-path> --clean -o out.txt

Environment:
    MISTRAL_API_KEY   - Mistral API key (default provider)
    OPENAI_API_KEY    - OpenAI API key
    ANTHROPIC_API_KEY - Anthropic API key
    GEMINI_API_KEY    - Google Gemini API key
"""

import sys
import os
import base64
import json
import subprocess
import re
from pathlib import Path
from urllib.request import Request, urlopen
from urllib.error import HTTPError, URLError

# ═══════════════════════════════════════════════════════════════════════════════
# CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

SUPPORTED_EXTENSIONS = {".png", ".jpg", ".jpeg", ".webp", ".avif", ".gif", ".bmp"}
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB

MIME_TYPES = {
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".webp": "image/webp",
    ".avif": "image/avif",
    ".gif": "image/gif",
    ".bmp": "image/bmp",
}

# Provider configurations
PROVIDERS = {
    "mistral": {
        "name": "Mistral",
        "endpoint": "https://api.mistral.ai/v1/ocr",
        "env_key": "MISTRAL_API_KEY",
        "default_model": "mistral-ocr-latest",
        "supports_ocr": True,
    },
    "openai": {
        "name": "OpenAI",
        "endpoint": "https://api.openai.com/v1/chat/completions",
        "env_key": "OPENAI_API_KEY",
        "default_model": "gpt-4o",
        "supports_ocr": False,
    },
    "anthropic": {
        "name": "Anthropic",
        "endpoint": "https://api.anthropic.com/v1/messages",
        "env_key": "ANTHROPIC_API_KEY",
        "default_model": "claude-3-5-sonnet-20241022",
        "supports_ocr": False,
    },
    "gemini": {
        "name": "Google Gemini",
        "endpoint": "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent",
        "env_key": "GEMINI_API_KEY",
        "default_model": "gemini-2.0-flash-exp",
        "supports_ocr": False,
    },
}

DEFAULT_PROVIDER = "mistral"

# ═══════════════════════════════════════════════════════════════════════════════
# HELPERS
# ═══════════════════════════════════════════════════════════════════════════════

def print_usage():
    print("""
imgcopy - Multi-provider image text extraction and cleanup

Usage:
    imgcopy <image-path> [options]

Options:
    --clean, -C         Format, sanitize, and copy to clipboard
    --copy, -c          Copy to clipboard (without cleanup)
    -p, --provider      Provider: mistral (default), openai, anthropic, gemini
    -m, --model         Specific model ID to use
    -o <file>           Save output to file
    --help, -h          Show this help message

Environment Variables:
    MISTRAL_API_KEY     Mistral API key (default provider)
    OPENAI_API_KEY      OpenAI API key
    ANTHROPIC_API_KEY   Anthropic API key
    GEMINI_API_KEY      Google Gemini API key

Examples:
    imgcopy screenshot.png
    imgcopy document.jpg --clean
    imgcopy photo.png -p openai --clean
    imgcopy scan.jpg -m gpt-4o-mini --clean -o output.txt

Get API Keys:
    Mistral:   https://console.mistral.ai/api-keys
    OpenAI:    https://platform.openai.com/api-keys
    Anthropic: https://console.anthropic.com/settings/keys
    Gemini:    https://aistudio.google.com/app/apikey
""")


def get_mime_type(file_path: Path) -> str:
    return MIME_TYPES.get(file_path.suffix.lower(), "image/jpeg")


def encode_image_to_base64(file_path: Path) -> str:
    with open(file_path, "rb") as f:
        return base64.b64encode(f.read()).decode("utf-8")


def copy_to_clipboard(text: str) -> bool:
    try:
        if sys.platform == "darwin":
            subprocess.run(["pbcopy"], input=text.encode(), check=True)
            return True
        elif sys.platform.startswith("linux"):
            subprocess.run(["xclip", "-selection", "clipboard"], input=text.encode(), check=True)
            return True
        elif sys.platform == "win32":
            subprocess.run(["clip"], input=text.encode(), check=True)
            return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    return False


def clean_text(text: str) -> str:
    """
    Clean and format extracted text:
    - Remove extra whitespace
    - Fix markdown formatting
    - Remove OCR artifacts
    - Smart paragraph joining
    """
    # Remove common OCR artifacts (random single characters, excessive punctuation)
    text = re.sub(r'\b[^\w\s]{3,}\b', '', text)  # Remove strings of 3+ special chars
    text = re.sub(r'(?<!\n)\n(?!\n)(?=[A-Z])', ' ', text)  # Join lines that end mid-sentence

    # Fix markdown formatting
    text = re.sub(r'\*\*\s+', '**', text)  # Fix "** text" -> "**text"
    text = re.sub(r'\s+\*\*', '**', text)  # Fix "text **" -> "text**"
    text = re.sub(r'#{1,6}\s*\n', '', text)  # Remove orphaned headers

    # Remove extra whitespace
    text = re.sub(r' +', ' ', text)  # Multiple spaces -> single space
    text = re.sub(r'\n{3,}', '\n\n', text)  # Max 2 consecutive newlines
    text = re.sub(r'[ \t]+\n', '\n', text)  # Remove trailing whitespace

    # Smart paragraph joining: if a line doesn't end with sentence-ending punctuation,
    # join it with the next line (unless next line starts with special formatting)
    lines = text.split('\n')
    cleaned_lines = []
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            cleaned_lines.append('')
            i += 1
            continue

        # Check if this line should be joined with next
        if i + 1 < len(lines):
            next_line = lines[i + 1].strip()
            # Join if current line doesn't end with sentence punctuation and next line doesn't start with special chars
            if (line and not re.search(r'[.!?:;]$', line) and
                next_line and not re.match(r'^[\*\-\#\d\[]', next_line)):
                cleaned_lines.append(line + ' ' + next_line)
                i += 2
                continue

        cleaned_lines.append(line)
        i += 1

    text = '\n'.join(cleaned_lines)

    # Final cleanup: trim leading/trailing whitespace
    text = text.strip()

    return text


# ═══════════════════════════════════════════════════════════════════════════════
# API CALLS
# ═══════════════════════════════════════════════════════════════════════════════

def call_mistral_ocr(api_key: str, image_data_url: str, model: str) -> str:
    request_body = json.dumps({
        "model": model,
        "document": {
            "type": "image_url",
            "image_url": {"url": image_data_url}
        }
    }).encode("utf-8")

    req = Request(
        PROVIDERS["mistral"]["endpoint"],
        data=request_body,
        headers={
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}",
        },
        method="POST"
    )

    try:
        with urlopen(req) as response:
            data = json.loads(response.read().decode("utf-8"))
            pages = data.get("pages", [])
            if not pages:
                return ""

            return "\n\n---\n\n".join(
                page.get("markdown", "").strip()
                for page in sorted(pages, key=lambda p: p.get("index", 0))
                if page.get("markdown", "").strip()
            )
    except HTTPError as e:
        raise RuntimeError(handle_http_error(e, "mistral"))
    except URLError as e:
        raise RuntimeError(f"Network error: {e.reason}")


def call_openai_vision(api_key: str, image_data_url: str, model: str) -> str:
    request_body = json.dumps({
        "model": model,
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": "Extract all text from this image. Preserve formatting and structure. Return ONLY the extracted text, no commentary."
                    },
                    {
                        "type": "image_url",
                        "image_url": {"url": image_data_url}
                    }
                ]
            }
        ],
        "max_tokens": 4096
    }).encode("utf-8")

    req = Request(
        PROVIDERS["openai"]["endpoint"],
        data=request_body,
        headers={
            "Content-Type": "application/json",
            "Authorization": f"Bearer {api_key}",
        },
        method="POST"
    )

    try:
        with urlopen(req) as response:
            data = json.loads(response.read().decode("utf-8"))
            return data["choices"][0]["message"]["content"].strip()
    except HTTPError as e:
        raise RuntimeError(handle_http_error(e, "openai"))
    except URLError as e:
        raise RuntimeError(f"Network error: {e.reason}")


def call_anthropic_vision(api_key: str, base64_data: str, mime_type: str, model: str) -> str:
    request_body = json.dumps({
        "model": model,
        "max_tokens": 4096,
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                        "type": "image",
                        "source": {
                            "type": "base64",
                            "media_type": mime_type,
                            "data": base64_data
                        }
                    },
                    {
                        "type": "text",
                        "text": "Extract all text from this image. Preserve formatting and structure. Return ONLY the extracted text, no commentary."
                    }
                ]
            }
        ]
    }).encode("utf-8")

    req = Request(
        PROVIDERS["anthropic"]["endpoint"],
        data=request_body,
        headers={
            "Content-Type": "application/json",
            "x-api-key": api_key,
            "anthropic-version": "2023-06-01"
        },
        method="POST"
    )

    try:
        with urlopen(req) as response:
            data = json.loads(response.read().decode("utf-8"))
            return data["content"][0]["text"].strip()
    except HTTPError as e:
        raise RuntimeError(handle_http_error(e, "anthropic"))
    except URLError as e:
        raise RuntimeError(f"Network error: {e.reason}")


def call_gemini_vision(api_key: str, base64_data: str, mime_type: str, model: str) -> str:
    endpoint = PROVIDERS["gemini"]["endpoint"].format(model=model)

    request_body = json.dumps({
        "contents": [
            {
                "parts": [
                    {
                        "inline_data": {
                            "mime_type": mime_type,
                            "data": base64_data
                        }
                    },
                    {
                        "text": "Extract all text from this image. Preserve formatting and structure. Return ONLY the extracted text, no commentary."
                    }
                ]
            }
        ]
    }).encode("utf-8")

    req = Request(
        f"{endpoint}?key={api_key}",
        data=request_body,
        headers={"Content-Type": "application/json"},
        method="POST"
    )

    try:
        with urlopen(req) as response:
            data = json.loads(response.read().decode("utf-8"))
            return data["candidates"][0]["content"]["parts"][0]["text"].strip()
    except HTTPError as e:
        raise RuntimeError(handle_http_error(e, "gemini"))
    except URLError as e:
        raise RuntimeError(f"Network error: {e.reason}")


def handle_http_error(e: HTTPError, provider: str) -> str:
    error_body = e.read().decode("utf-8")
    error_msg = f"API request failed with status {e.code}"

    try:
        error_json = json.loads(error_body)
        error_msg = (
            error_json.get("message") or
            error_json.get("detail") or
            error_json.get("error", {}).get("message") or
            error_msg
        )
    except json.JSONDecodeError:
        pass

    if e.code == 401:
        error_msg = f"Invalid API key for {provider}. Check your {PROVIDERS[provider]['env_key']}."
    elif e.code == 403:
        error_msg = f"API key does not have permission. Check your {provider} account."
    elif e.code == 429:
        error_msg = "Rate limit exceeded. Please wait and try again."

    return error_msg


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

def main():
    args = sys.argv[1:]

    if not args or "--help" in args or "-h" in args:
        print_usage()
        sys.exit(0 if args else 1)

    # Parse arguments
    image_path = None
    provider = DEFAULT_PROVIDER
    model = None
    clean = False
    copy_to_clip = False
    output_file = None

    i = 0
    while i < len(args):
        arg = args[i]
        if arg in ("--clean", "-C"):
            clean = True
            copy_to_clip = True  # --clean auto-copies
        elif arg in ("--copy", "-c"):
            copy_to_clip = True
        elif arg in ("-p", "--provider") and i + 1 < len(args):
            i += 1
            provider = args[i].lower()
        elif arg in ("-m", "--model") and i + 1 < len(args):
            i += 1
            model = args[i]
        elif arg == "-o" and i + 1 < len(args):
            i += 1
            output_file = args[i]
        elif not arg.startswith("-"):
            image_path = arg
        i += 1

    if not image_path:
        print("Error: No image path provided", file=sys.stderr)
        print_usage()
        sys.exit(1)

    # Validate provider
    if provider not in PROVIDERS:
        print(f"Error: Unknown provider '{provider}'", file=sys.stderr)
        print(f"Supported providers: {', '.join(PROVIDERS.keys())}", file=sys.stderr)
        sys.exit(1)

    provider_config = PROVIDERS[provider]

    # Set default model if not specified
    if not model:
        model = provider_config["default_model"]

    # Check API key
    api_key = os.environ.get(provider_config["env_key"])
    if not api_key:
        print(f"Error: {provider_config['env_key']} environment variable is not set", file=sys.stderr)
        print(f"Get your API key at the URL shown in --help", file=sys.stderr)
        sys.exit(1)

    # Resolve and validate image path
    resolved_path = Path(image_path).resolve()

    if not resolved_path.exists():
        print(f"Error: File not found: {resolved_path}", file=sys.stderr)
        sys.exit(1)

    file_size = resolved_path.stat().st_size
    if file_size > MAX_FILE_SIZE:
        print(f"Error: File too large ({file_size / 1024 / 1024:.1f}MB). Maximum is 50MB.", file=sys.stderr)
        sys.exit(1)

    ext = resolved_path.suffix.lower()
    if ext not in SUPPORTED_EXTENSIONS:
        print(f"Error: Unsupported file type: {ext}", file=sys.stderr)
        print(f"Supported types: {', '.join(SUPPORTED_EXTENSIONS)}", file=sys.stderr)
        sys.exit(1)

    # Process image
    print(f"Processing: {resolved_path.name} ({file_size / 1024:.1f} KB)", file=sys.stderr)
    print(f"Provider: {provider_config['name']} ({model})", file=sys.stderr)

    try:
        # Encode image
        base64_data = encode_image_to_base64(resolved_path)
        mime_type = get_mime_type(resolved_path)
        data_url = f"data:{mime_type};base64,{base64_data}"

        # Call appropriate API
        print("Extracting text...", file=sys.stderr)

        if provider == "mistral":
            extracted_text = call_mistral_ocr(api_key, data_url, model)
        elif provider == "openai":
            extracted_text = call_openai_vision(api_key, data_url, model)
        elif provider == "anthropic":
            extracted_text = call_anthropic_vision(api_key, base64_data, mime_type, model)
        elif provider == "gemini":
            extracted_text = call_gemini_vision(api_key, base64_data, mime_type, model)
        else:
            raise RuntimeError(f"Provider {provider} not implemented")

        if not extracted_text.strip():
            print("No text found in image.", file=sys.stderr)
            sys.exit(0)

        # Clean text if requested
        if clean:
            print("Cleaning and formatting text...", file=sys.stderr)
            extracted_text = clean_text(extracted_text)

        # Output
        print(extracted_text)

        # Copy to clipboard if requested
        if copy_to_clip:
            if copy_to_clipboard(extracted_text):
                print("\n✓ Copied to clipboard", file=sys.stderr)
            else:
                print("\n✗ Failed to copy to clipboard", file=sys.stderr)

        # Save to file if requested
        if output_file:
            Path(output_file).write_text(extracted_text, encoding="utf-8")
            print(f"✓ Saved to {output_file}", file=sys.stderr)

    except RuntimeError as e:
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
